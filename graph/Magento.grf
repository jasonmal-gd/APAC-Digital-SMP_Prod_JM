<?xml version="1.0" encoding="UTF-8"?>
<Graph author="macmac" created="Mon May 26 11:20:13 EST 2014" guiVersion="3.4.4.P" id="1401087269149" licenseType="Commercial" modified="Wed Jun 18 16:50:26 EST 2014" modifiedBy="macmac" name="Magento" revision="1.45" showComponentDetails="true">
<Global>
<Metadata id="Metadata1" previewAttachmentCharset="UTF-8">
<Record fieldDelimiter="|" name="Magento" previewAttachmentCharset="UTF-8" recordDelimiter="\n" type="delimited">
<Field name="entity_id" type="string"/>
<Field name="attribute_set_id" type="string"/>
<Field name="type_id" type="string"/>
</Record>
</Metadata>
<Metadata id="Metadata0" previewAttachmentCharset="ISO-8859-1">
<Record fieldDelimiter="|" name="Response" previewAttachmentCharset="ISO-8859-1" recordDelimiter="\n" type="delimited">
<Field name="response" type="string"/>
</Record>
</Metadata>
<Metadata id="TreeReader_ErrPortWithoutFile">
<Record fieldDelimiter="|" name="XMLReader_TreeReader_ErrPortWithoutFile" recordDelimiter="\n" type="delimited">
<Field name="port" type="integer"/>
<Field name="recordNumber" type="integer"/>
<Field name="fieldNumber" type="integer"/>
<Field name="fieldName" type="string"/>
<Field name="value" type="string"/>
<Field name="message" type="string"/>
</Record>
</Metadata>
<Property fileURL="workspace.prm" id="GraphParameter0"/>
<Note alignment="1" backgroundColorB="225" backgroundColorG="255" backgroundColorR="255" enabled="true" folded="false" height="241" id="Note0" textColorB="0" textColorG="0" textColorR="0" textFontSize="12" title="Magento 10 products data" titleColorB="0" titleColorG="0" titleColorR="0" titleFontSize="14" width="867" x="-29" y="121"/>
<Dictionary/>
</Global>
<Phase number="0">
<Node enabled="enabled" fileURL="${DATA_SOURCE_DIR}/Magento.csv" guiName="CSV Writer" guiX="587" guiY="163" id="CSV_WRITER" outputFieldNames="true" type="DATA_WRITER"/>
<Node enabled="enabled" fileURL="${DATA_SOURCE_DIR}/response.txt" guiName="CSV Writer" guiX="384" guiY="263" id="CSV_WRITER1" outputFieldNames="false" type="DATA_WRITER"/>
<Node authConfiguration="{&quot;authMethod&quot;:&quot;OAUTH_1&quot;,&quot;authCredentials&quot;:{&quot;CONSUMER_SECRET&quot;:&quot;5zxs30lJyD57YsoyxPEFzneVOLN98mORSO4BnepywWaURAhGwJSI1A==&quot;,&quot;TOKEN_SECRET&quot;:&quot;MN2BykbBdTJmnDB7r3AiA1DZInlEAyh/anXbSV8jjkPK1zw9Krrw1A==&quot;,&quot;TOKEN_KEY&quot;:&quot;g5amoly4xr4kuchxkywk0r56yzhbpzbo&quot;,&quot;CONSUMER_KEY&quot;:&quot;ik7rgki4wk3k1pjy9ws1n5kq5st4nh9o&quot;}}" charset="UTF-8" ctlFunctionsSource="//#CTL2&#10;&#10;/**&#10; * Generates request parameters (usually page numbers, offsets, timestamps, signature hashes,etc.)&#10; * Called before each request.&#10; *&#10; * Last response is is only defined if iteration number is greater than one. Therefore, for the very first request&#10; * lastResponseStatus is 200, lastResponseHeaders and lastResponseBody are empty.&#10; *&#10; * If input port is connected, incoming data record can be accessed through $in.0.fieldName&#10; *&#10; * inputEdgeRecord - contains fields of the input edge record&#10; * iterationNumber - starts at 1&#10; * lastResponseStatus - HTTP status of the previous request&#10; * lastResponseHeaders - HTTP headers of the previous request&#10; * lastResponseBody -  body of the previous request&#10; *&#10; * returns a map of params that can be used in the request URL&#10;**/&#10;function map[string, string] generateRequestParameters(map[string, string] inputEdgeRecord, integer iterationNumber, integer lastResponseStatus, map[string, string]lastResponseHeaders, string lastResponseBody) {&#10;&#10;    // Copy all input parameters into the request parameters map.&#10;    map[string, string] requestParams = inputEdgeRecord;&#10;&#10;    /**&#10;     *  PAGING&#10;     *&#10;     *  (Tip: comment/uncomment the code suitable for your use case)&#10;     **/&#10;&#10;    /** Using pages **/&#10;    requestParams[&quot;PAGE_NO&quot;] = toString(iterationNumber);&#10;&#10;    /** Using start offset and end offset **/&#10;    // integer RECORDS_PER_PAGE = 1000;&#10;    // requestParams[&quot;START_OFFSET&quot;] = toString((iterationNumber - 1) * RECORDS_PER_PAGE); //starts at 0&#10;    // requestParams[&quot;END_OFFSET&quot;] = toString((iterationNumber * RECORDS_PER_PAGE) - 1);&#10;&#10;    /*** Using start offset and records count ***/&#10;    // integer RECORDS_PER_PAGE = 1000;&#10;    // requestParams[&quot;START_OFFSET&quot;] = toString((iterationNumber - 1) * RECORDS_PER_PAGE); //starts at 0&#10;    // requestParams[&quot;RECORDS_PER_PAGE&quot;] = toString(RECORDS_PER_PAGE);&#10;&#10;    return requestParams;&#10;}&#10;&#10;/**&#10; * Determines the outcome of the response. Used for controlling the paging workflow and detecting errors.&#10; * Called after each request response.&#10; *&#10; * Default implementations returns &quot;DONE_WITH_OUTPUT&quot; to make one REST call and finish.&#10; *&#10; * If input port is connected, incoming data record can be accessed through $in.0.fieldName&#10; *&#10; * responseStatus - response HTTP status&#10; * responseHeaders - response HTTP headers&#10; * responseBody -  response body&#10; *&#10; * returns&#10; *  CONTINUE - continue to next iteration (e.g., next page)&#10; *  DONE_NO_OUTPUT (default) - last iteration finished, no data will be sent to the output port for the last iteration (no data received from the last iteration)&#10; *  DONE_WITH_OUTPUT - last iteration finished, data will be sent to the output for the last iteration (data received from the last iteration)&#10; *  RETRY - retry the last failed request&#10; *  FATAL_ERROR - fatal error, aborts the HTTP connector run&#10;**/&#10;function string checkResponse(integer responseStatus, map[string, string] responseHeaders, string responseBody) {&#10;    return &quot;DONE_WITH_OUTPUT&quot;;&#10;&#10;    // Example response handling&#10;    // if (responseStatus &gt;= 200  &amp;&amp;  responseStatus &lt; 300) {&#10;    //     return &quot;CONTINUE&quot;;&#10;    // }&#10;    // else if (responseStatus == 404) {&#10;    //     // HTTP status &quot;404 - NOT FOUND&quot; could mean there are no more pages or records&#10;    //     return &quot;DONE_NO_OUTPUT&quot;;&#10;    // }&#10;    // else if (responseStatus &gt;= 500 || responseBody.indexOf('{&quot;error&quot;: &quot;just a temporary error&quot;}') &gt; -1) {&#10;    //     // Internal server errors could be temporary (this sends the last response to the error output port)&#10;    //     return &quot;RETRY&quot;;&#10;    // }&#10;    // else {&#10;    //     // Otherwise abort the HTTP connector run (this sends the last response to the error output port)&#10;    //     return &quot;FATAL_ERROR&quot;;&#10;    // }&#10;}&#10;&#10;/**&#10; * Updates the request params before each request retry attempt if it failed previously.&#10; * Useful for resetting authorization parameter (signatures, tokens, etc.), updating timestamp, etc.&#10; *&#10; * Optional. When not defined, the request stays the same.&#10; *&#10; * If input port is connected, incoming data record can be accessed through $in.0.fieldName&#10; *&#10; * failedRequestParams original parameters of request which failed and should be retried&#10; * retryNumber number of current retry, &quot;1&quot; for the first retry&#10; * lastResponseStatus - HTTP status of the failed request&#10; * lastResponseHeaders - HTTP headers of the failed request&#10; * lastResponseBody -  body of the failed request&#10; *&#10; * returns map of the modified params for the retry request&#10;**/&#10;function map[string, string] modifyRequestParamsBeforeRetryAttempt(map[string, string] failedRequestParams, integer retryNumber,&#10;        integer responseStatus, map[string, string] responseHeaders, string responseBody) {&#10;&#10;    // Copy all the previous parameters into the retry request parameters map.&#10;    map[string, string] modifiedRequestParams = failedRequestParams;&#10;&#10;    /*** Modify the params of the request ***/&#10;&#10;    // Example of timestamp modification&#10;    // modifiedRequestParams[&quot;TIMESTAMP&quot;] = toString(date2long(today()));&#10;&#10;    return modifiedRequestParams;&#10;}" enabled="enabled" guiName="Production Connector" guiX="-15" guiY="175" id="PRODUCTION_CONNECTOR" requestMethod="GET" type="GENERIC_REST_CONNECTOR">
<attr name="url"><![CDATA[http://www.cellarmasterwines.com/api/rest/products?limit=10]]></attr>
<attr name="requestHeaders"><![CDATA[Accept=text/xml
Content-Type=text/xml
]]></attr>
</Node>
<Node authConfiguration="{&quot;authMethod&quot;:&quot;OAUTH_1&quot;,&quot;authCredentials&quot;:{&quot;CONSUMER_SECRET&quot;:&quot;E64L+0oWD0AlrtCoHbYAN/So+g69l7C19j3xYFUuvEtucmQTSspCTQ==&quot;,&quot;TOKEN_SECRET&quot;:&quot;9HkA2AJTRbwXvb52D9aQx7t0jwN3wcNb44kQfS2k8Ge3J9MDULLEIA==&quot;,&quot;TOKEN_KEY&quot;:&quot;8nkugt670d6dklmln0r5a623e7xoet9g&quot;,&quot;CONSUMER_KEY&quot;:&quot;8cff4cz085606t7nekkkm4dh3lhj7x2z&quot;}}" charset="UTF-8" ctlFunctionsSource="//#CTL2&#10;&#10;/**&#10; * Generates request parameters (usually page numbers, offsets, timestamps, signature hashes,etc.)&#10; * Called before each request.&#10; *&#10; * Last response is is only defined if iteration number is greater than one. Therefore, for the very first request&#10; * lastResponseStatus is 200, lastResponseHeaders and lastResponseBody are empty.&#10; *&#10; * If input port is connected, incoming data record can be accessed through $in.0.fieldName&#10; *&#10; * inputEdgeRecord - contains fields of the input edge record&#10; * iterationNumber - starts at 1&#10; * lastResponseStatus - HTTP status of the previous request&#10; * lastResponseHeaders - HTTP headers of the previous request&#10; * lastResponseBody -  body of the previous request&#10; *&#10; * returns a map of params that can be used in the request URL&#10;**/&#10;function map[string, string] generateRequestParameters(map[string, string] inputEdgeRecord, integer iterationNumber, integer lastResponseStatus, map[string, string]lastResponseHeaders, string lastResponseBody) {&#10;&#10;    // Copy all input parameters into the request parameters map.&#10;    map[string, string] requestParams = inputEdgeRecord;&#10;&#10;    /**&#10;     *  PAGING&#10;     *&#10;     *  (Tip: comment/uncomment the code suitable for your use case)&#10;     **/&#10;&#10;    /** Using pages **/&#10;    requestParams[&quot;PAGE_NO&quot;] = toString(iterationNumber);&#10;&#10;    /** Using start offset and end offset **/&#10;    // integer RECORDS_PER_PAGE = 1000;&#10;    // requestParams[&quot;START_OFFSET&quot;] = toString((iterationNumber - 1) * RECORDS_PER_PAGE); //starts at 0&#10;    // requestParams[&quot;END_OFFSET&quot;] = toString((iterationNumber * RECORDS_PER_PAGE) - 1);&#10;&#10;    /*** Using start offset and records count ***/&#10;    // integer RECORDS_PER_PAGE = 1000;&#10;    // requestParams[&quot;START_OFFSET&quot;] = toString((iterationNumber - 1) * RECORDS_PER_PAGE); //starts at 0&#10;    // requestParams[&quot;RECORDS_PER_PAGE&quot;] = toString(RECORDS_PER_PAGE);&#10;&#10;    return requestParams;&#10;}&#10;&#10;/**&#10; * Determines the outcome of the response. Used for controlling the paging workflow and detecting errors.&#10; * Called after each request response.&#10; *&#10; * Default implementations returns &quot;DONE_WITH_OUTPUT&quot; to make one REST call and finish.&#10; *&#10; * If input port is connected, incoming data record can be accessed through $in.0.fieldName&#10; *&#10; * responseStatus - response HTTP status&#10; * responseHeaders - response HTTP headers&#10; * responseBody -  response body&#10; *&#10; * returns&#10; *  CONTINUE - continue to next iteration (e.g., next page)&#10; *  DONE_NO_OUTPUT (default) - last iteration finished, no data will be sent to the output port for the last iteration (no data received from the last iteration)&#10; *  DONE_WITH_OUTPUT - last iteration finished, data will be sent to the output for the last iteration (data received from the last iteration)&#10; *  RETRY - retry the last failed request&#10; *  FATAL_ERROR - fatal error, aborts the HTTP connector run&#10;**/&#10;function string checkResponse(integer responseStatus, map[string, string] responseHeaders, string responseBody) {&#10;    return &quot;DONE_WITH_OUTPUT&quot;;&#10;&#10;    // Example response handling&#10;    // if (responseStatus &gt;= 200  &amp;&amp;  responseStatus &lt; 300) {&#10;    //     return &quot;CONTINUE&quot;;&#10;    // }&#10;    // else if (responseStatus == 404) {&#10;    //     // HTTP status &quot;404 - NOT FOUND&quot; could mean there are no more pages or records&#10;    //     return &quot;DONE_NO_OUTPUT&quot;;&#10;    // }&#10;    // else if (responseStatus &gt;= 500 || responseBody.indexOf('{&quot;error&quot;: &quot;just a temporary error&quot;}') &gt; -1) {&#10;    //     // Internal server errors could be temporary (this sends the last response to the error output port)&#10;    //     return &quot;RETRY&quot;;&#10;    // }&#10;    // else {&#10;    //     // Otherwise abort the HTTP connector run (this sends the last response to the error output port)&#10;    //     return &quot;FATAL_ERROR&quot;;&#10;    // }&#10;}&#10;&#10;/**&#10; * Updates the request params before each request retry attempt if it failed previously.&#10; * Useful for resetting authorization parameter (signatures, tokens, etc.), updating timestamp, etc.&#10; *&#10; * Optional. When not defined, the request stays the same.&#10; *&#10; * If input port is connected, incoming data record can be accessed through $in.0.fieldName&#10; *&#10; * failedRequestParams original parameters of request which failed and should be retried&#10; * retryNumber number of current retry, &quot;1&quot; for the first retry&#10; * lastResponseStatus - HTTP status of the failed request&#10; * lastResponseHeaders - HTTP headers of the failed request&#10; * lastResponseBody -  body of the failed request&#10; *&#10; * returns map of the modified params for the retry request&#10;**/&#10;function map[string, string] modifyRequestParamsBeforeRetryAttempt(map[string, string] failedRequestParams, integer retryNumber,&#10;        integer responseStatus, map[string, string] responseHeaders, string responseBody) {&#10;&#10;    // Copy all the previous parameters into the retry request parameters map.&#10;    map[string, string] modifiedRequestParams = failedRequestParams;&#10;&#10;    /*** Modify the params of the request ***/&#10;&#10;    // Example of timestamp modification&#10;    // modifiedRequestParams[&quot;TIMESTAMP&quot;] = toString(date2long(today()));&#10;&#10;    return modifiedRequestParams;&#10;}" enabled="disabled" guiName="REST Connector" guiX="-2" guiY="57" id="REST_CONNECTOR" requestMethod="GET" type="GENERIC_REST_CONNECTOR">
<attr name="url"><![CDATA[http://cellarmasterwines.staging.nextdigital.com/api/rest/products?limit=10]]></attr>
<attr name="requestHeaders"><![CDATA[Accept=text/xml
Content-Type=text/xml
]]></attr>
</Node>
<Node enabled="enabled" guiName="SimpleCopy" guiX="197" guiY="168" id="SIMPLE_COPY" type="SIMPLE_COPY"/>
<Node enabled="enabled" fileURL="port:$0.response:discrete" guiName="XMLXPathReader" guiX="384" guiY="163" id="XMLXPATH_READER" mapping="&lt;Context xpath=&quot;/magento_api/data_item&quot; outPort=&quot;0&quot;&gt;&#10;&#9;&lt;Mapping xpath=&quot;entity_id&quot; cloverField=&quot;entity_id&quot;/&gt;&#10;&#9;&lt;Mapping xpath=&quot;attribute_set_id&quot; cloverField=&quot;attribute_set_id&quot;/&gt;&#10;&lt;!--&#10;&lt;Mapping xpath=&quot;&quot; outPort=&quot;&quot; cloverField=&quot;&quot;/&gt;&#10;&lt;Mapping xpath=&quot;&quot; cloverField=&quot;&quot;/&gt;&#10;&#10;&#10;--&gt;&#10;&#10;&lt;/Context&gt;" type="XML_XPATH_READER"/>
<Edge debugMode="true" fromNode="PRODUCTION_CONNECTOR:0" guiBendpoints="" guiRouter="Manhattan" id="Edge0" inPort="Port 0 (in)" metadata="Metadata0" outPort="Port 0 (output)" toNode="SIMPLE_COPY:0"/>
<Edge fromNode="SIMPLE_COPY:0" guiBendpoints="" guiRouter="Manhattan" id="Edge1" inPort="Port 0 (in)" metadata="Metadata0" outPort="Port 0 (out)" toNode="XMLXPATH_READER:0"/>
<Edge fromNode="SIMPLE_COPY:1" guiBendpoints="" guiRouter="Manhattan" id="Edge2" inPort="Port 0 (in)" metadata="Metadata0" outPort="Port 1 (out)" toNode="CSV_WRITER1:0"/>
<Edge debugMode="true" fromNode="XMLXPATH_READER:0" guiBendpoints="" guiRouter="Manhattan" id="Edge4" inPort="Port 0 (in)" metadata="Metadata1" outPort="Port 0 (out)" toNode="CSV_WRITER:0"/>
</Phase>
</Graph>
